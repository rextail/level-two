package dev04

import (
	"slices"
	"strings"
)

/*
Написать функцию поиска всех множеств анаграмм по словарю.
	Например:
		'пятак', 'пятка' и 'тяпка' - принадлежат одному множеству,
		'листок', 'слиток' и 'столик' - другому.
	Требования:
		1. Входные данные для функции: ссылка на массив, каждый элемент которого - слово на русском языке в кодировке utf8
		2. Выходные данные: ссылка на мапу множеств анаграмм
		2. Ключ - первое встретившееся в словаре слово из множества. Значение - ссылка на массив, каждый элемент которого,
		слово из множества.
		3. Массив должен быть отсортирован по возрастанию.
		4. Множества из одного элемента не должны попасть в результат.
		5. Все слова должны быть приведены к нижнему регистру.
		6. В результате каждое слово должно встречаться только один раз.

	План решения:
		Отсортировывать массив рун из каждого слова. Так как любое слово из множества в отсортированном виде
		будет представлять собой один и тот же набор символов, то будем использовать это свойство для определения
		принадлежности слова ко множеству. Назовем это корнем множества.
		В отдельной мапе будем хранить ассоциацию корня множества с первым элементом этого множества
		И в еще одной мапе будем хранить все значения, чтобы быстро вылавливать дубликаты
*/

func FindAllAnagramms(words []string) map[string][]string {
	//Ключом будет отсортированный элемент, а значением - первый встретившийся элемент этого множества
	roots := make(map[string]string, len(words))
	//Для быстрой проверки на повторные элементы. Ключ - слово, значение - отсортированный элемент множества
	used := make(map[string]struct{}, len(words))
	//Результат
	res := make(map[string][]string, len(words))

	for _, word := range words {
		word = strings.ToLower(word)

		runed := []rune(word)

		slices.Sort(runed)

		sorted := string(runed)

		if _, ok := roots[sorted]; !ok {
			//Если это первый элемент множества
			roots[sorted] = word
		}
		//достаем множество по первому элементу этого множества(roots[sorted) и добавляем туда еще один элемент
		if _, ok := used[word]; !ok {
			//если этот элемент еще не встречался
			res[roots[sorted]] = append(res[roots[sorted]], word)
		}
		//помечаем, что этот элемент уже был использован
		used[word] = struct{}{}
	}

	for key, value := range res {
		//избавимся от множеств из одного элемента и отсортируем элементы
		if len(value) == 1 {
			delete(res, key)
		} else {
			//сортируем множество, если не было удалено
			slices.Sort(res[key])
		}
	}
	return res
}
