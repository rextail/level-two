package factory

import "fmt"

/*
	Фабричный метод - паттерн, идея которого основана на активном использовании наследования.
	Так как Go напрямую не поддерживает наследование, это уже приводит нас к тому, что нам необходимо
	искать какой-то обходной путь.
	А есть ли смысл искать обходной путь, если мы обходим базу паттерна?
	В Go нет наследования. Его идеология это простота и прямолинейность. Интерфейсы принято определять по месту
	использования, а не на стороне производителя, как предлагает нам этот паттерн.
	Если попытка реализовать паттерн требует создания искусственных абстракций или сложных схем,
	которые противоречат духу языка, возможно, стоит пересмотреть подход и использовать более простое решение.

	Если нам необходимо создать какой-то объект в Go, мы обычно делаем что-то вроде простого конструктора:
*/

type Idioma struct {
	slogan string
}

func NewIdioma(slogan string) Idioma {
	return Idioma{slogan: slogan}
}

//Добавим метод

func (i *Idioma) YieldSlogan() {
	fmt.Println(i.slogan + "!!!")
}

//А затем там, где будем его использовать, определяем интерфейс

type SloganYielder interface {
	YieldSlogan()
}
