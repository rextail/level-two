package state

/*
	Поведенческий паттерн, в основе которого заложена идея, похожая на "Стратегию", однако если "Стратегия" фокусируется
	на том, чтобы менять одно поведение на другое в рамках одного конкретного алгоритма, то паттерн "Состояние"
	делает акцент как раз на состоянии системы, от которого зависит ее поведение.
	"Стратегия" - это про то, как выполнять определенную задачу
	"Состояние" - это про то, что и когда выполнять

	Аналогично со стратегией, мы создадим отдельные объекты, которым будем делегировать выполнение задач, но теперь
	управление не обязано быть целиком в руках клиента, конкретные состояния могут знать о существовании друг-друга
	и передавать управление при необходимости

	Представим небольшой вендинговый аппарат. Пусть у него будет на выбор газировка, сок и вода.

	Опишем состояния, в которых он может находиться:
		1. Ожидает фиксации выбора, т.е нажатия кнопки оплаты. До оплаты можно тыкать кнопки и менять свой выбор без проблем.
		2. После нажатия кнопки переходим к ожиданию оплаты. Для простоты опустим способ оплаты.
		В данном состоянии кнопки выбора напитка уже не работают. Можно нажать кнопку отмены и вернуться к выбору напитка
		3. После оплаты отдаем напиток. Для простоты опустим таймеры и пр. автоматизацию.

	Считаем, что напитки не могут закончиться
*/

type State interface {
	ToPaymentConfirmation()
	CancelPayment()
	ConfirmPayment(inputSum byte)
	GiveOutDrink()
}

/*
	Паттерн применим тогда, когда необходимо/удобно выделить состояния объекта, в которых его
	реакция на одни и те же события отличается.

	Плюсы:
		1. Четкое разделение ответственности
		2. Уменьшение связанности кода
		3. Гибкость
	Минусы:
		1. Увеличивается количество структур, система становится сложнее
*/
