package command

/*
	Суть паттерна заключается в том, чтобы инкапсулировать какую-либо команду в отдельный объект.
	Система разделяется на следующие объекты:
		1. Получатель - объект, содержащий бизнес-логику
		2. Команда - объект, который привязан к получателю и запускает выполнение его бизнес-логики
		3. Инвокер - один из объектов, который умеет выполнять команду. Т.е. точки запуска команды могут быть разные, но
		благодаря тому, что каждый инвокер содержит команду, связанную с бизнес-логикой, нам не приходится дублировать код
		4. Клиент - связующее звено, которое связывает команду и получателя, а затем инвокера и команду.

	Таким образом можно уменьшить дублирование кода и удобно связывать внешние объекты с бизнес-логикой.

	Представим, что у нас есть умный чайник. Его можно включить как через приложение, так и вручную.
*/

//Теперь мы хотим аккуратно связать два способа включить чайник с нашей мини бизнес-логикой.
//Разграничим интерфейсы. Ограничим их поведение.

type DeviceEnabler interface {
	Enable() bool
}

type DeviceDisabler interface {
	Disable() bool
}

//Плюсы:
//Достаточно просто добавлять новые способы включения чайника. Например, можно легко добавить
//управление через умную станцию. Мы разделяем запросы на выполнение бизнес-логики от самой бизнес-логики.
//Удобное взаимодействие с бизнес-логикой
//Минусы:
//Не самый идиоматичный подход в контексте Go, поскольку здесь принято использовать более прямолинейные методы
//и не принято мусорить объектами и абстракциями.
//Большое количество объектов затрудняет понимание кода читателем
//Особенно в контексте, дополнительные объекты и абстракции могут усложнить конкурентность
