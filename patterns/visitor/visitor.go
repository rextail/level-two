package visitor

import "fmt"

/*
	Паттерн применяется в тех случаях, когда необходимо реализовать добавление новой
	функциональности в структуру без ее фактического изменения

	Например, мы написали библиотеку. Сначала у нас был интерфейс, описывающий поведение некоторых объектов.
	Затем какая-нибудь другая команда из компании попросила нас добавить еще одно поведение.
	Самый нативным решением было бы просто добавить еще один метод в интерфейс и реализовать его для
	всех, кто хочет его реализовывать.
	Однако если таких запросов становится очень много, тогда мы лучше предоставим коллегам
	возможность самим расширять функциональность, не изменяя при этом наш код.

	Например, у нас есть библиотека с персонажами для компьютерных игр.
*/

type Character interface {
	accept(v Visitor)
}

//Создадим интерфейс visitor, который поможет нам расширять способности классов персонажей, не изменяя их

// Здесь описаны обобщенные методы для каждого класса персонажа

type Visitor interface {
	VisitForWarrior(w *Warrior)
	VisitForMage(m *Mage)
	VisitForDruid(d *Druid)
}

//Теперь создадим структуру, которая будет расширять поведение наших персонажей

type CharacterRester struct {
}

func (c *CharacterRester) VisitForWarrior(w *Warrior) {
	fmt.Println("Воин отдыхает...")
}
func (c *CharacterRester) VisitForMage(m *Mage) {
	fmt.Println("Маг отдыхает...")
}
func (c *CharacterRester) VisitForDruid(m *Druid) {
	fmt.Println("Друид отдыхает...")
}

/*
	Теперь, определяя каждый раз структуры, подобные CharacterRester и определяя в методах
	поведение для каждого реализующего общий интерфейс объекта, мы можем расширять поведение, не изменяя
	при этом существующий код

	Плюсы:
		1. расширение функциональности для существующих компонентов без необходимости изменений в коде,
		что соответствует OCP дяди Боба.
		2. Достаточно просто обернуть это дело тестами
		3. Отделение логики работы от самих структур. Таким образом код становится более гибким.
	Минусы:
		1. добавление ранее несуществующего компонента повлечет за собой необходимость в огромном количестве изменений
		2. использование интерфейсов как-никак влияет на производительность
		3. при большом количестве компонентов становится трудоемко описывать поведение для каждого
*/
